/*
     raw os - Copyright (C)  Lingjun Chen(jorya_txj).

    This file is part of raw os.

    raw os is free software; you can redistribute it it under the terms of the 
    GNU General Public License as published by the Free Software Foundation; 
    either version 3 of the License, or  (at your option) any later version.

    raw os is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
    without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
    See the GNU General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program. if not, write email to jorya.txj@gmail.com
                                      ---

    A special exception to the LGPL can be applied should you wish to distribute
    a combined work that includes raw os, without being obliged to provide
    the source code for any proprietary components. See the file exception.txt
    for full details of how and when the exception can be applied.
*/


/* 	2012-8  Created by jorya_txj
  *	xxxxxx   please added here
  */


#ifndef RSH_H
#define RSH_H

#ifdef __cplusplus
extern "C" {
#endif


#define configCOMMAND_INT_MAX_OUTPUT_SIZE 4096

	
	
/* ∂œ—‘≈‰÷√ ------------------------------------------------------------------*/
#define  RAW_ASSERT(CON)        if (!(CON)) {volatile CPU_INT08U dummy = 0; CPU_SR_Save(); while (dummy == 0);}
/* The prototype to which callback functions used to process command line
commands must comply.  pcWriteBuffer is a buffer into which the output from 
executing the command can be written, xWriteBufferLen is the length, in bytes of 
the pcWriteBuffer buffer, and pcCommandString is the entire string as input by
the user (from which parameters can be extracted).*/
typedef CPU_INT32S (*pdCOMMAND_LINE_CALLBACK)( CPU_INT08S *pcWriteBuffer, CPU_INT32U xWriteBufferLen, const CPU_INT08S * pcCommandString );

/* The structure that defines command line commands.  A command line command
should be defined by declaring a const structure of this type. */
typedef struct xCOMMAND_LINE_INPUT
{
	const CPU_INT08S * const pcCommand;				/* The command that causes pxCommandInterpreter to be executed.  For example "help".  Must be all lower case. */
	const CPU_INT08S * const pcHelpString;				/* String that describes how to use the command.  Should start with the command itself, and end with "\r\n".  For example "help: Returns a list of all the commands\r\n". */
	const pdCOMMAND_LINE_CALLBACK pxCommandInterpreter;	/* A pointer to the callback function that will return the output generated by the command. */
	CPU_INT08S cExpectedNumberOfParameters;			/* Commands expect a fixed number of parameters, which may be zero. */
} xCommandLineInput;


typedef struct xCOMMAND_INPUT_LIST
{
	const xCommandLineInput *pxCommandLineDefinition;
	struct xCOMMAND_INPUT_LIST *pxNext;
} xCommandLineInputListItem;


/*
 * Register the command passed in using the pxCommandToRegister parameter.
 * Registering a command adds the command to the list of commands that are
 * handled by the command interpreter.  Once a command has been registered it
 * can be executed from the command line.
 */
void rsh_register_command(const xCommandLineInput * const pxCommandToRegister, xCommandLineInputListItem *pxNewListItem);

/*
 * Runs the command interpreter for the command string "pcCommandInput".  Any
 * output generated by running the command will be placed into pcWriteBuffer.
 * xWriteBufferLen must indicate the size, in bytes, of the buffer pointed to
 * by pcWriteBuffer.
 *
 * rsh_process_command should be called repeatedly until it returns pdFALSE.
 *
 * pcCmdIntProcessCommand is not reentrant.  It must not be called from more
 * than one task - or at least - by more than one task at a time.
 */
CPU_INT32S rsh_process_command( const CPU_INT08S * const pcCommandInput, CPU_INT08S * pcWriteBuffer, CPU_INT32U xWriteBufferLen  );
CPU_INT32S rsh_process_key(CPU_INT08S key_code);

/*-----------------------------------------------------------*/
//int raw_strncmp(const char *cs, const char *ct, CPU_INT32U count);

//void *raw_memset(void *src, CPU_INT08U byte, CPU_INT32U count);

/*
 * Return a pointer to the xParameterNumber'th word in pcCommandString.
 */
CPU_INT08S *rsh_get_parameter(const CPU_INT08S *pcCommandString, CPU_INT32S uxWantedParameter, CPU_INT32S *pxParameterStringLength );

CPU_INT08S rsh_get_parameters_numbers( const CPU_INT08S * pcCommandString );

#ifdef __cplusplus
}
#endif

#endif /* COMMAND_INTERPRETER_H */



